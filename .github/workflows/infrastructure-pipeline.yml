name: Infrastructure Pipeline
#PUSH TO MAIN BRANCH
on:
  push:
    branches: [ main ]
    paths:
      - 'terraform/**'
      - '.github/workflows/infrastructure-pipeline.yml'
  pull_request:
    branches: [ main ]
    paths:
      - 'terraform/**'
      - '.github/workflows/infrastructure-pipeline.yml'

permissions:
  contents: read
  pull-requests: write
  issues: write

env:
  AWS_REGION: us-east-1
  TERRAFORM_VERSION: "1.5.0"
  TFLINT_VERSION: "v0.44.1"

jobs:
  # 1. Create remote backend (only S3 and DynamoDB)
  create-backend:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Set up Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      - name: Init Terraform (local backend)
        working-directory: terraform
        run: terraform init

      # RELEASE LOCK BEFORE APPLYING BACKEND
      - name: Try to release ALL Terraform locks if exist
        working-directory: terraform
        run: |
          LOCK_IDS=$(aws dynamodb scan \
            --table-name epam-final-terraform-locks \
            --filter-expression "attribute_exists(LockID)" \
            --query "Items[].LockID.S" \
            --output text)
          for LOCK_ID in $LOCK_IDS; do
            if [ "$LOCK_ID" != "None" ] && [ "$LOCK_ID" != "" ]; then
              terraform force-unlock -force "$LOCK_ID" || true
            fi
          done
        shell: bash
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_DEFAULT_REGION: ${{ env.AWS_REGION }}

      - name: Apply only backend resources (with retry and unlock)
        working-directory: terraform
        run: |
          for i in 1 2 3; do
            LOCK_IDS=$(aws dynamodb scan \
              --table-name epam-final-terraform-locks \
              --filter-expression "attribute_exists(LockID)" \
              --query "Items[].LockID.S" \
              --output text)
            for LOCK_ID in $LOCK_IDS; do
              if [ "$LOCK_ID" != "None" ] && [ "$LOCK_ID" != "" ]; then
                terraform force-unlock -force "$LOCK_ID" || true
              fi
            done

            terraform apply -auto-approve \
              -target=aws_s3_bucket.terraform_state \
              -target=aws_dynamodb_table.terraform_locks \
              -var="api_key=${{ secrets.API_KEY }}" && break

            echo "Apply failed, retrying in 10 seconds (attempt $i of 3)..."
            sleep 10
          done
        shell: bash
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_DEFAULT_REGION: ${{ env.AWS_REGION }}

  # 2. The rest of your original pipeline, which depends on the backend
  terraform:
    runs-on: ubuntu-latest
    needs: create-backend
    steps:
      - uses: actions/checkout@v3

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup TFLint
        run: |
          curl -s https://raw.githubusercontent.com/terraform-linters/tflint/master/install_linux.sh | bash

      - name: Run TFLint
        run: |
          cd terraform
          tflint --init
          tflint --format=compact

      - name: Run tfsec (Terraform security analysis)
        run: |
          curl -s https://raw.githubusercontent.com/aquasecurity/tfsec/master/scripts/install_linux.sh | bash
          tfsec terraform/

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}

      - name: Create Terraform Variables File
        run: |
          cd terraform
          cat > terraform.tfvars <<EOF
          aws_region = "${{ env.AWS_REGION }}"
          api_key = "${{ secrets.API_KEY }}"
          EOF

      - name: Temporarily move terraform.tfvars
        run: |
          cd terraform
          mv terraform.tfvars terraform.tfvars.bak

      - name: Terraform Format
        id: fmt
        run: |
          cd terraform
          terraform fmt -check

      - name: Restore terraform.tfvars
        run: |
          cd terraform
          mv terraform.tfvars.bak terraform.tfvars

      - name: Debug terraform.tfvars
        run: |
          cat terraform/terraform.tfvars

      - name: Terraform Init
        id: init
        run: |
          cd terraform
          terraform init

      - name: Terraform Validate
        id: validate
        run: |
          cd terraform
          terraform validate -no-color

      - name: Terraform Plan
        id: plan
        if: github.event_name == 'pull_request'
        run: |
          cd terraform
          terraform plan -no-color
        continue-on-error: true

      - name: Update Pull Request
        uses: actions/github-script@v6
        if: github.event_name == 'pull_request'
        env:
          PLAN: "${{ steps.plan.outputs.stdout }}"
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const output = `#### Terraform Format and Style 🖌\`${{ steps.fmt.outcome }}\`
            #### Terraform Initialization ⚙️\`${{ steps.init.outcome }}\`
            #### Terraform Validation 🤖\`${{ steps.validate.outcome }}\`
            #### Terraform Plan 📖\`${{ steps.plan.outcome }}\`
            
            <details><summary>Show Plan</summary>
            
            \`\`\`\n
            ${process.env.PLAN}
            \`\`\`
            
            </details>`;
            
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: output
            })

      - name: Try to release ALL Terraform locks if exist
        working-directory: terraform
        run: |
          LOCK_IDS=$(aws dynamodb scan \
            --table-name epam-final-terraform-locks \
            --filter-expression "attribute_exists(LockID)" \
            --query "Items[].LockID.S" \
            --output text)
          for LOCK_ID in $LOCK_IDS; do
            if [ "$LOCK_ID" != "None" ] && [ "$LOCK_ID" != "" ]; then
              terraform force-unlock -force "$LOCK_ID" || true
            fi
          done
        shell: bash
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_DEFAULT_REGION: ${{ env.AWS_REGION }}

      - name: Try to release ALL Terraform locks if exist (before import)
        working-directory: terraform
        run: |
          LOCK_IDS=$(aws dynamodb scan \
            --table-name epam-final-terraform-locks \
            --filter-expression "attribute_exists(LockID)" \
            --query "Items[].LockID.S" \
            --output text)
          for LOCK_ID in $LOCK_IDS; do
            if [ "$LOCK_ID" != "None" ] && [ "$LOCK_ID" != "" ]; then
              terraform force-unlock -force "$LOCK_ID" || true
            fi
          done
        shell: bash
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_DEFAULT_REGION: ${{ env.AWS_REGION }}

      - name: Import existing resources if needed
        working-directory: terraform
        run: |
          set -e

          # S3 Bucket for state
          if aws s3api head-bucket --bucket epam-final-terraform-state > /dev/null 2>&1; then
            echo "Importing S3 state bucket..."
            terraform import aws_s3_bucket.terraform_state epam-final-terraform-state || true
          fi

          # DynamoDB Table for locks
          if aws dynamodb describe-table --table-name epam-final-terraform-locks > /dev/null 2>&1; then
            echo "Importing DynamoDB lock table..."
            terraform import aws_dynamodb_table.terraform_locks epam-final-terraform-locks || true
          fi

          # KMS Key (by alias)
          KMS_KEY_ID=$(aws kms list-aliases --query "Aliases[?AliasName=='alias/eks-encryption-key'].TargetKeyId" --output text)
          if [ ! -z "$KMS_KEY_ID" ] && [ "$KMS_KEY_ID" != "None" ]; then
            echo "Importing KMS Key and Alias..."
            terraform import module.eks.aws_kms_key.eks $KMS_KEY_ID || true
            terraform import module.eks.aws_kms_alias.eks alias/eks-encryption-key || true
          fi

          # IAM Roles
          if aws iam get-role --role-name eks-cluster-role > /dev/null 2>&1; then
            echo "Importing IAM Role eks-cluster-role..."
            terraform import module.eks.aws_iam_role.cluster eks-cluster-role || true
          fi
          if aws iam get-role --role-name eks-node-role > /dev/null 2>&1; then
            echo "Importing IAM Role eks-node-role..."
            terraform import module.eks.aws_iam_role.node eks-node-role || true
          fi
          if aws iam get-role --role-name fastapi-sa-role > /dev/null 2>&1; then
            echo "Importing IAM Role fastapi-sa-role..."
            terraform import module.eks.aws_iam_role.fastapi_sa fastapi-sa-role || true
          fi
          if aws iam get-role --role-name vpc-flow-log-role > /dev/null 2>&1; then
            echo "Importing IAM Role vpc-flow-log-role..."
            terraform import module.vpc.aws_iam_role.flow_log vpc-flow-log-role || true
          fi

          # Secrets Manager
          if aws secretsmanager describe-secret --secret-id fastapi/api_key2 > /dev/null 2>&1; then
            echo "Importing Secret fastapi/api_key2..."
            terraform import module.eks.aws_secretsmanager_secret.api_key fastapi/api_key2 || true
          fi

          # Public subnets
          for i in 1 2; do
            SUBNET_ID=$(aws ec2 describe-subnets --filters "Name=tag:Name,Values=public-subnet-$i" --query "Subnets[0].SubnetId" --output text)
            if [ "$SUBNET_ID" != "None" ]; then
              echo "Importing public Subnet $i..."
              terraform import "module.vpc.aws_subnet.public[$((i-1))]" $SUBNET_ID || true
            fi
          done

          # Private subnets
          for i in 1 2; do
            SUBNET_ID=$(aws ec2 describe-subnets --filters "Name=tag:Name,Values=private-subnet-$i" --query "Subnets[0].SubnetId" --output text)
            if [ "$SUBNET_ID" != "None" ]; then
              echo "Importing private Subnet $i..."
              terraform import "module.vpc.aws_subnet.private[$((i-1))]" $SUBNET_ID || true
            fi
          done

          # CloudWatch Log Group for VPC Flow Logs
          if aws logs describe-log-groups --log-group-name-prefix /aws/vpc/flow-logs | grep /aws/vpc/flow-logs > /dev/null 2>&1; then
            echo "Importing VPC Flow Logs Log Group..."
            terraform import module.vpc.aws_cloudwatch_log_group.flow_log /aws/vpc/flow-logs || true
          fi

          # EKS Node Group
          NODEGROUP_NAME="main"
          CLUSTER_NAME="my-eks-cluster"
          if aws eks describe-nodegroup --cluster-name $CLUSTER_NAME --nodegroup-name $NODEGROUP_NAME > /dev/null 2>&1; then
            echo "Importing EKS Node Group $NODEGROUP_NAME..."
            terraform import module.eks.aws_eks_node_group.main $CLUSTER_NAME:$NODEGROUP_NAME || true
          fi

          # NAT Gateway
          NAT_GW_ID=$(aws ec2 describe-nat-gateways --filter "Name=state,Values=available" --query "NatGateways[0].NatGatewayId" --output text)
          if [ "$NAT_GW_ID" != "None" ] && [ "$NAT_GW_ID" != "" ]; then
            echo "Importing NAT Gateway..."
            terraform import module.vpc.aws_nat_gateway.main $NAT_GW_ID || true
          fi

          # EIP for NAT Gateway
          EIP_ALLOC_ID=$(aws ec2 describe-addresses --query "Addresses[?AssociationId!=null].AllocationId" --output text)
          if [ "$EIP_ALLOC_ID" != "None" ] && [ "$EIP_ALLOC_ID" != "" ]; then
            echo "Importing EIP for NAT Gateway..."
            terraform import module.vpc.aws_eip.nat $EIP_ALLOC_ID || true
          fi
        shell: bash
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_DEFAULT_REGION: ${{ env.AWS_REGION }}

      - name: Clean up Terraform Variables File
        if: always()
        run: |
          cd terraform
          rm -f terraform.tfvars

      - name: Create ECR repository if it doesn't exist
        run: |
          aws ecr describe-repositories --repository-names fastapi-app --region ${{ env.AWS_REGION }} || \
          aws ecr create-repository --repository-name fastapi-app --region ${{ env.AWS_REGION }}
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_DEFAULT_REGION: ${{ env.AWS_REGION }}

      - name: Terraform Apply
        if: github.ref == 'refs/heads/main' && github.event_name == 'push'
        run: |
          cd terraform
          terraform apply -auto-approve

      - name: Ensure S3 bucket for backend exists
        run: |
          if ! aws s3api head-bucket --bucket epam-final-terraform-state --region ${{ env.AWS_REGION }} 2>/dev/null; then
            echo "S3 bucket epam-final-terraform-state does not exist. Creating..."
            aws s3api create-bucket --bucket epam-final-terraform-state --region ${{ env.AWS_REGION }}
          else
            echo "S3 bucket epam-final-terraform-state already exists."
          fi
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_DEFAULT_REGION: ${{ env.AWS_REGION }}

      - name: Ensure DynamoDB table for backend exists
        run: |
          if ! aws dynamodb describe-table --table-name epam-final-terraform-locks --region ${{ env.AWS_REGION }} 2>/dev/null; then
            echo "DynamoDB table epam-final-terraform-locks does not exist. Creating..."
            aws dynamodb create-table \
              --table-name epam-final-terraform-locks \
              --attribute-definitions AttributeName=LockID,AttributeType=S \
              --key-schema AttributeName=LockID,KeyType=HASH \
              --billing-mode PAY_PER_REQUEST \
              --region ${{ env.AWS_REGION }}
          else
            echo "DynamoDB table epam-final-terraform-locks already exists."
          fi
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_DEFAULT_REGION: ${{ env.AWS_REGION }}

      - name: Wait for backend resources to be available
        run: |
          for i in {1..10}; do
            aws s3api head-bucket --bucket epam-final-terraform-state --region ${{ env.AWS_REGION }} && \
            aws dynamodb describe-table --table-name epam-final-terraform-locks --region ${{ env.AWS_REGION }} && break
            echo "Waiting for backend resources to be available... ($i/10)"
            sleep 5
          done
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_DEFAULT_REGION: ${{ env.AWS_REGION }}
